[
  {
    "content": "// @generated by pothos-protoc-gen v0.0.3 with parameter "builder_path=../builder"
// @generated from file user.proto (package user.v1, syntax proto3)
/* eslint-disable */

import { builder } from "../builder";
import { create, enumFromJson } from "@bufbuild/protobuf";
import type { CreateUserRequest, CreateUserResponse, DeleteUserRequest, DeleteUserResponse, GetUserRequest, GetUserResponse, ListUsersRequest, ListUsersResponse, UpdateUserRequest, UpdateUserResponse, User } from "./user_pb";
import { CreateUserRequestSchema, DeleteUserRequestSchema, GetUserRequestSchema, ListUsersRequestSchema, UpdateUserRequestSchema, User_UserStatusSchema, UserRoleSchema, UserSchema } from "./user_pb";

/**
 * @generated from enum user.v1.UserRole
 */
export const UserV1UserRoleRef = builder.enumType('UserV1UserRole', {
  description: "",
  values: {
    /**
     * @generated from enum value: ROLE_UNSPECIFIED = 0;
     */
    'ROLE_UNSPECIFIED': {
      value: enumFromJson(UserRoleSchema, "ROLE_UNSPECIFIED"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: ROLE_ADMIN = 1;
     */
    'ROLE_ADMIN': {
      value: enumFromJson(UserRoleSchema, "ROLE_ADMIN"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: ROLE_USER = 2;
     */
    'ROLE_USER': {
      value: enumFromJson(UserRoleSchema, "ROLE_USER"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: ROLE_GUEST = 3;
     */
    'ROLE_GUEST': {
      value: enumFromJson(UserRoleSchema, "ROLE_GUEST"),
      description: "",
      deprecated: false,
    },
  } as const,
});

/**
 * @generated from enum user.v1.User.UserStatus
 */
export const UserV1User_UserStatusRef = builder.enumType('UserV1User_UserStatus', {
  description: "",
  values: {
    /**
     * @generated from enum value: STATUS_UNSPECIFIED = 0;
     */
    'STATUS_UNSPECIFIED': {
      value: enumFromJson(User_UserStatusSchema, "STATUS_UNSPECIFIED"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: STATUS_ACTIVE = 1;
     */
    'STATUS_ACTIVE': {
      value: enumFromJson(User_UserStatusSchema, "STATUS_ACTIVE"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: STATUS_INACTIVE = 2;
     */
    'STATUS_INACTIVE': {
      value: enumFromJson(User_UserStatusSchema, "STATUS_INACTIVE"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: STATUS_SUSPENDED = 3;
     */
    'STATUS_SUSPENDED': {
      value: enumFromJson(User_UserStatusSchema, "STATUS_SUSPENDED"),
      description: "",
      deprecated: false,
    },
  } as const,
});

/**
 * @generated from message user.v1.CreateUserResponse
 */
export const UserV1CreateUserResponseRef = builder.objectRef<CreateUserResponse>('UserV1CreateUserResponse').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: user.v1.User user = 1;
     */
    user: t.field({
      type: "UserV1User",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.user,
    }),
  }),
});

/**
 * @generated from message user.v1.User
 */
export const UserV1UserRef = builder.objectRef<User>('UserV1User').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.id,
    }),
    /**
     * @generated from field: string name = 2;
     */
    name: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.name,
    }),
    /**
     * @generated from field: string email = 3;
     */
    email: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.email,
    }),
    /**
     * @generated from field: user.v1.UserRole role = 4;
     */
    role: t.field({
      type: "UserV1UserRole",
      description: "",
      deprecationReason: "",
      resolve: (parent) => enumFromJson(UserRoleSchema, parent.role),
    }),
    /**
     * @generated from field: user.v1.User.UserStatus status = 5;
     */
    status: t.field({
      type: "UserV1User_UserStatus",
      description: "",
      deprecationReason: "",
      resolve: (parent) => enumFromJson(User_UserStatusSchema, parent.status),
    }),
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: t.field({
      type: ["StringMapEntry"],
      description: "",
      deprecationReason: "",
      resolve: (parent) => Object.entries(parent.metadata).map(([key, value]) => ({ key: String(key), value: value })),
    }),
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: t.field({
      type: ["String"],
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.tags,
    }),
    /**
     * @generated from field: int64 created_at = 8;
     */
    createdAt: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => (parent.createdAt)?.toString(),
    }),
    /**
     * @generated from field: int64 updated_at = 9;
     */
    updatedAt: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => (parent.updatedAt)?.toString(),
    }),
  }),
});

/**
 * @generated from message user.v1.GetUserResponse
 */
export const UserV1GetUserResponseRef = builder.objectRef<GetUserResponse>('UserV1GetUserResponse').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: user.v1.User user = 1;
     */
    user: t.field({
      type: "UserV1User",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.user,
    }),
  }),
});

/**
 * @generated from message user.v1.UpdateUserResponse
 */
export const UserV1UpdateUserResponseRef = builder.objectRef<UpdateUserResponse>('UserV1UpdateUserResponse').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: user.v1.User user = 1;
     */
    user: t.field({
      type: "UserV1User",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.user,
    }),
  }),
});

/**
 * @generated from message user.v1.DeleteUserResponse
 */
export const UserV1DeleteUserResponseRef = builder.objectRef<DeleteUserResponse>('UserV1DeleteUserResponse').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: bool success = 1;
     */
    success: t.field({
      type: "Boolean",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.success,
    }),
  }),
});

/**
 * @generated from message user.v1.ListUsersResponse
 */
export const UserV1ListUsersResponseRef = builder.objectRef<ListUsersResponse>('UserV1ListUsersResponse').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: repeated user.v1.User users = 1;
     */
    users: t.field({
      type: ["UserV1User"],
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.users,
    }),
    /**
     * @generated from field: string next_page_token = 2;
     */
    nextPageToken: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.nextPageToken,
    }),
    /**
     * @generated from field: int32 total_count = 3;
     */
    totalCount: t.field({
      type: "Int",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.totalCount,
    }),
  }),
});

/**
 * @generated from message user.v1.CreateUserRequest
 */
export const UserV1CreateUserRequestInputRef = builder.inputRef<CreateUserRequest>('UserV1CreateUserRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string name = 1;
     */
    name: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: string email = 2;
     */
    email: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: user.v1.UserRole role = 3;
     */
    role: t.field({
      type: "UserV1UserRole",
      description: "",
    }),
    /**
     * @generated from field: map<string, string> metadata = 4;
     */
    metadata: t.field({
      type: ["StringMapEntryInput"],
      description: "",
    }),
    /**
     * @generated from field: repeated string tags = 5;
     */
    tags: t.field({
      type: ["String"],
      description: "",
    }),
  }),
});

/**
 * @generated from message user.v1.GetUserRequest
 */
export const UserV1GetUserRequestInputRef = builder.inputRef<GetUserRequest>('UserV1GetUserRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
  }),
});

/**
 * @generated from message user.v1.UpdateUserRequest
 */
export const UserV1UpdateUserRequestInputRef = builder.inputRef<UpdateUserRequest>('UserV1UpdateUserRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: optional string name = 2;
     */
    name: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: optional string email = 3;
     */
    email: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: optional user.v1.UserRole role = 4;
     */
    role: t.field({
      type: "UserV1UserRole",
      description: "",
    }),
    /**
     * @generated from field: optional user.v1.User.UserStatus status = 5;
     */
    status: t.field({
      type: "UserV1User_UserStatus",
      description: "",
    }),
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: t.field({
      type: ["StringMapEntryInput"],
      description: "",
    }),
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: t.field({
      type: ["String"],
      description: "",
    }),
  }),
});

/**
 * @generated from message user.v1.DeleteUserRequest
 */
export const UserV1DeleteUserRequestInputRef = builder.inputRef<DeleteUserRequest>('UserV1DeleteUserRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
  }),
});

/**
 * @generated from message user.v1.ListUsersRequest
 */
export const UserV1ListUsersRequestInputRef = builder.inputRef<ListUsersRequest>('UserV1ListUsersRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: int32 page_size = 1;
     */
    pageSize: t.field({
      type: "Int",
      description: "",
    }),
    /**
     * @generated from field: string page_token = 2;
     */
    pageToken: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: optional user.v1.User.UserStatus status = 3;
     */
    status: t.field({
      type: "UserV1User_UserStatus",
      description: "",
    }),
    /**
     * @generated from field: optional user.v1.UserRole role = 4;
     */
    role: t.field({
      type: "UserV1UserRole",
      description: "",
    }),
  }),
});

/**
 * @generated from message user.v1.User
 */
export const UserV1UserInputRef = builder.inputRef<User>('UserV1UserInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: string name = 2;
     */
    name: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: string email = 3;
     */
    email: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: user.v1.UserRole role = 4;
     */
    role: t.field({
      type: "UserV1UserRole",
      description: "",
    }),
    /**
     * @generated from field: user.v1.User.UserStatus status = 5;
     */
    status: t.field({
      type: "UserV1User_UserStatus",
      description: "",
    }),
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: t.field({
      type: ["StringMapEntryInput"],
      description: "",
    }),
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: t.field({
      type: ["String"],
      description: "",
    }),
    /**
     * @generated from field: int64 created_at = 8;
     */
    createdAt: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: int64 updated_at = 9;
     */
    updatedAt: t.field({
      type: "String",
      description: "",
    }),
  }),
});

/**
 * A function to make a user.v1.CreateUserRequest input
 */
export function makeUserV1CreateUserRequestInput(input: any): CreateUserRequest {
  return create(CreateUserRequestSchema, {
    /**
     * @generated from field: string name = 1;
     */
    name: input?.name,
    /**
     * @generated from field: string email = 2;
     */
    email: input?.email,
    /**
     * @generated from field: user.v1.UserRole role = 3;
     */
    role: input?.role,
    /**
     * @generated from field: map<string, string> metadata = 4;
     */
    metadata: input?.metadata ? Object.fromEntries(input?.metadata?.map(({ key, value }) => [key, value])) : null,
    /**
     * @generated from field: repeated string tags = 5;
     */
    tags: input?.tags,
  });
}

/**
 * A function to make a user.v1.GetUserRequest input
 */
export function makeUserV1GetUserRequestInput(input: any): GetUserRequest {
  return create(GetUserRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
  });
}

/**
 * A function to make a user.v1.UpdateUserRequest input
 */
export function makeUserV1UpdateUserRequestInput(input: any): UpdateUserRequest {
  return create(UpdateUserRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
    /**
     * @generated from field: optional string name = 2;
     */
    name: input?.name,
    /**
     * @generated from field: optional string email = 3;
     */
    email: input?.email,
    /**
     * @generated from field: optional user.v1.UserRole role = 4;
     */
    role: input?.role,
    /**
     * @generated from field: optional user.v1.User.UserStatus status = 5;
     */
    status: input?.status,
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: input?.metadata ? Object.fromEntries(input?.metadata?.map(({ key, value }) => [key, value])) : null,
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: input?.tags,
  });
}

/**
 * A function to make a user.v1.DeleteUserRequest input
 */
export function makeUserV1DeleteUserRequestInput(input: any): DeleteUserRequest {
  return create(DeleteUserRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
  });
}

/**
 * A function to make a user.v1.ListUsersRequest input
 */
export function makeUserV1ListUsersRequestInput(input: any): ListUsersRequest {
  return create(ListUsersRequestSchema, {
    /**
     * @generated from field: int32 page_size = 1;
     */
    pageSize: input?.pageSize,
    /**
     * @generated from field: string page_token = 2;
     */
    pageToken: input?.pageToken,
    /**
     * @generated from field: optional user.v1.User.UserStatus status = 3;
     */
    status: input?.status,
    /**
     * @generated from field: optional user.v1.UserRole role = 4;
     */
    role: input?.role,
  });
}

/**
 * A function to make a user.v1.User input
 */
export function makeUserV1UserInput(input: any): User {
  return create(UserSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
    /**
     * @generated from field: string name = 2;
     */
    name: input?.name,
    /**
     * @generated from field: string email = 3;
     */
    email: input?.email,
    /**
     * @generated from field: user.v1.UserRole role = 4;
     */
    role: input?.role,
    /**
     * @generated from field: user.v1.User.UserStatus status = 5;
     */
    status: input?.status,
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: input?.metadata ? Object.fromEntries(input?.metadata?.map(({ key, value }) => [key, value])) : null,
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: input?.tags,
    /**
     * @generated from field: int64 created_at = 8;
     */
    createdAt: input?.createdAt,
    /**
     * @generated from field: int64 updated_at = 9;
     */
    updatedAt: input?.updatedAt,
  });
}

/**
 * @generated from rpc user.v1.UserService.CreateUser
 */
builder.mutationField('userV1UserServiceCreateUser', t => t.field({
  /**
   * @generated from message user.v1.CreateUserResponse
   */
  type: "UserV1CreateUserResponse",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message user.v1.CreateUserRequest
     */
    input: t.arg({
      type: "UserV1CreateUserRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.userV1UserService) throw new Error('userV1UserService is not provided.');
    return context.userV1UserService.createUser(
      makeUserV1CreateUserRequestInput(input),
      { headers: context.userV1UserServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc user.v1.UserService.GetUser
 */
builder.queryField('userV1UserServiceGetUser', t => t.field({
  /**
   * @generated from message user.v1.GetUserResponse
   */
  type: "UserV1GetUserResponse",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message user.v1.GetUserRequest
     */
    input: t.arg({
      type: "UserV1GetUserRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.userV1UserService) throw new Error('userV1UserService is not provided.');
    return context.userV1UserService.getUser(
      makeUserV1GetUserRequestInput(input),
      { headers: context.userV1UserServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc user.v1.UserService.UpdateUser
 */
builder.mutationField('userV1UserServiceUpdateUser', t => t.field({
  /**
   * @generated from message user.v1.UpdateUserResponse
   */
  type: "UserV1UpdateUserResponse",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message user.v1.UpdateUserRequest
     */
    input: t.arg({
      type: "UserV1UpdateUserRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.userV1UserService) throw new Error('userV1UserService is not provided.');
    return context.userV1UserService.updateUser(
      makeUserV1UpdateUserRequestInput(input),
      { headers: context.userV1UserServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc user.v1.UserService.DeleteUser
 */
builder.mutationField('userV1UserServiceDeleteUser', t => t.field({
  /**
   * @generated from message user.v1.DeleteUserResponse
   */
  type: "UserV1DeleteUserResponse",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message user.v1.DeleteUserRequest
     */
    input: t.arg({
      type: "UserV1DeleteUserRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.userV1UserService) throw new Error('userV1UserService is not provided.');
    return context.userV1UserService.deleteUser(
      makeUserV1DeleteUserRequestInput(input),
      { headers: context.userV1UserServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc user.v1.UserService.ListUsers
 */
builder.queryField('userV1UserServiceListUsers', t => t.field({
  /**
   * @generated from message user.v1.ListUsersResponse
   */
  type: "UserV1ListUsersResponse",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message user.v1.ListUsersRequest
     */
    input: t.arg({
      type: "UserV1ListUsersRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.userV1UserService) throw new Error('userV1UserService is not provided.');
    return context.userV1UserService.listUsers(
      makeUserV1ListUsersRequestInput(input),
      { headers: context.userV1UserServiceRequestHeaders },
    );
  },
}));

",
    "name": "user_pothos.ts",
  },
  {
    "content": "// @generated by pothos-protoc-gen v0.0.3 with parameter "builder_path=../builder"
// @generated from file post/post.proto (package post.v1, syntax proto3)
/* eslint-disable */

import { builder } from "../../builder";
import { create, enumFromJson } from "@bufbuild/protobuf";
import type { CreatePostRequest, DeletePostRequest, GetPostRequest, GetPostWithAuthorRequest, ListPostsRequest, ListPostsResponse, Post, PostWithAuthor, UpdatePostRequest } from "./post_pb";
import { CreatePostRequestSchema, DeletePostRequestSchema, GetPostRequestSchema, GetPostWithAuthorRequestSchema, ListPostsRequestSchema, PostCategorySchema, PostListFilterSchema, PostStatusSchema, UpdatePostRequestSchema } from "./post_pb";
import { makeUserV1UserInput } from "../user_pothos";

/**
 * @generated from enum post.v1.PostStatus
 */
export const PostV1PostStatusRef = builder.enumType('PostV1PostStatus', {
  description: "",
  values: {
    /**
     * @generated from enum value: POST_STATUS_UNSPECIFIED = 0;
     */
    'UNSPECIFIED': {
      value: enumFromJson(PostStatusSchema, "POST_STATUS_UNSPECIFIED"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_STATUS_DRAFT = 1;
     */
    'DRAFT': {
      value: enumFromJson(PostStatusSchema, "POST_STATUS_DRAFT"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_STATUS_PUBLISHED = 2;
     */
    'PUBLISHED': {
      value: enumFromJson(PostStatusSchema, "POST_STATUS_PUBLISHED"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_STATUS_ARCHIVED = 3;
     */
    'ARCHIVED': {
      value: enumFromJson(PostStatusSchema, "POST_STATUS_ARCHIVED"),
      description: "",
      deprecated: false,
    },
  } as const,
});

/**
 * @generated from enum post.v1.PostCategory
 */
export const PostV1PostCategoryRef = builder.enumType('PostV1PostCategory', {
  description: "",
  values: {
    /**
     * @generated from enum value: POST_CATEGORY_UNSPECIFIED = 0;
     */
    'UNSPECIFIED': {
      value: enumFromJson(PostCategorySchema, "POST_CATEGORY_UNSPECIFIED"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_CATEGORY_TECHNOLOGY = 1;
     */
    'TECHNOLOGY': {
      value: enumFromJson(PostCategorySchema, "POST_CATEGORY_TECHNOLOGY"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_CATEGORY_HEALTH = 2;
     */
    'HEALTH': {
      value: enumFromJson(PostCategorySchema, "POST_CATEGORY_HEALTH"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_CATEGORY_TRAVEL = 3;
     */
    'TRAVEL': {
      value: enumFromJson(PostCategorySchema, "POST_CATEGORY_TRAVEL"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_CATEGORY_FOOD = 4;
     */
    'FOOD': {
      value: enumFromJson(PostCategorySchema, "POST_CATEGORY_FOOD"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_CATEGORY_LIFESTYLE = 5;
     */
    'LIFESTYLE': {
      value: enumFromJson(PostCategorySchema, "POST_CATEGORY_LIFESTYLE"),
      description: "",
      deprecated: false,
    },
  } as const,
});

/**
 * @generated from enum post.v1.PostListFilter
 */
export const PostV1PostListFilterRef = builder.enumType('PostV1PostListFilter', {
  description: "",
  values: {
    /**
     * @generated from enum value: POST_LIST_FILTER_ALL = 0;
     */
    'ALL': {
      value: enumFromJson(PostListFilterSchema, "POST_LIST_FILTER_ALL"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_LIST_FILTER_PUBLISHED = 1;
     */
    'PUBLISHED': {
      value: enumFromJson(PostListFilterSchema, "POST_LIST_FILTER_PUBLISHED"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_LIST_FILTER_DRAFTS = 2;
     */
    'DRAFTS': {
      value: enumFromJson(PostListFilterSchema, "POST_LIST_FILTER_DRAFTS"),
      description: "",
      deprecated: false,
    },
    /**
     * @generated from enum value: POST_LIST_FILTER_ARCHIVED = 3;
     */
    'ARCHIVED': {
      value: enumFromJson(PostListFilterSchema, "POST_LIST_FILTER_ARCHIVED"),
      description: "",
      deprecated: false,
    },
  } as const,
});

/**
 * @generated from message post.v1.Post
 */
export const PostV1PostRef = builder.objectRef<Post>('PostV1Post').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.id,
    }),
    /**
     * @generated from field: string title = 2;
     */
    title: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.title,
    }),
    /**
     * @generated from field: string content = 3;
     */
    content: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.content,
    }),
    /**
     * @generated from field: post.v1.PostStatus status = 4;
     */
    status: t.field({
      type: "PostV1PostStatus",
      description: "",
      deprecationReason: "",
      resolve: (parent) => enumFromJson(PostStatusSchema, parent.status),
    }),
    /**
     * @generated from field: post.v1.PostCategory category = 5;
     */
    category: t.field({
      type: "PostV1PostCategory",
      description: "",
      deprecationReason: "",
      resolve: (parent) => enumFromJson(PostCategorySchema, parent.category),
    }),
    /**
     * @generated from field: string author_id = 6;
     */
    authorId: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.authorId,
    }),
    /**
     * @generated from field: google.protobuf.Timestamp created_at = 7;
     */
    createdAt: t.field({
      type: "GoogleProtobufTimestamp",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.createdAt,
    }),
    /**
     * @generated from field: google.protobuf.Timestamp updated_at = 8;
     */
    updatedAt: t.field({
      type: "GoogleProtobufTimestamp",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.updatedAt,
    }),
    /**
     * @generated from field: map<string, string> metadata = 9 [deprecated = true];
     * @deprecated
     */
    metadata: t.field({
      type: ["StringMapEntry"],
      description: "",
      deprecationReason: "",
      resolve: (parent) => Object.entries(parent.metadata).map(([key, value]) => ({ key: String(key), value: value })),
    }),
    /**
     * @generated from field: repeated string tags = 10;
     */
    tags: t.field({
      type: ["String"],
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.tags,
    }),
  }),
});

/**
 * @generated from message post.v1.ListPostsResponse
 */
export const PostV1ListPostsResponseRef = builder.objectRef<ListPostsResponse>('PostV1ListPostsResponse').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: repeated post.v1.Post posts = 1;
     */
    posts: t.field({
      type: ["PostV1Post"],
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.posts,
    }),
    /**
     * @generated from field: string next_page_token = 2;
     */
    nextPageToken: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.nextPageToken,
    }),
    /**
     * @generated from field: int32 total_count = 3;
     */
    totalCount: t.field({
      type: "Int",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.totalCount,
    }),
  }),
});

/**
 * @generated from message post.v1.PostWithAuthor
 */
export const PostV1PostWithAuthorRef = builder.objectRef<PostWithAuthor>('PostV1PostWithAuthor').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: post.v1.Post post = 1;
     */
    post: t.field({
      type: "PostV1Post",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.post,
    }),
    /**
     * @generated from field: user.v1.User author = 2;
     */
    author: t.field({
      type: "UserV1User",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.author,
    }),
  }),
});

/**
 * @generated from message post.v1.CreatePostRequest
 */
export const PostV1CreatePostRequestInputRef = builder.inputRef<CreatePostRequest>('PostV1CreatePostRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string title = 1;
     */
    title: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: string content = 2;
     */
    content: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: post.v1.PostStatus status = 3;
     */
    status: t.field({
      type: "PostV1PostStatus",
      description: "",
    }),
    /**
     * @generated from field: post.v1.PostCategory category = 4;
     */
    category: t.field({
      type: "PostV1PostCategory",
      description: "",
    }),
    /**
     * @generated from field: string author_id = 5;
     */
    authorId: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: t.field({
      type: ["StringMapEntryInput"],
      description: "",
    }),
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: t.field({
      type: ["String"],
      description: "",
    }),
  }),
});

/**
 * @generated from message post.v1.GetPostRequest
 */
export const PostV1GetPostRequestInputRef = builder.inputRef<GetPostRequest>('PostV1GetPostRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
  }),
});

/**
 * @generated from message post.v1.UpdatePostRequest
 */
export const PostV1UpdatePostRequestInputRef = builder.inputRef<UpdatePostRequest>('PostV1UpdatePostRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: string title = 2;
     */
    title: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: string content = 3;
     */
    content: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: post.v1.PostStatus status = 4;
     */
    status: t.field({
      type: "PostV1PostStatus",
      description: "",
    }),
    /**
     * @generated from field: post.v1.PostCategory category = 5;
     */
    category: t.field({
      type: "PostV1PostCategory",
      description: "",
    }),
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: t.field({
      type: ["StringMapEntryInput"],
      description: "",
    }),
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: t.field({
      type: ["String"],
      description: "",
    }),
  }),
});

/**
 * @generated from message post.v1.DeletePostRequest
 */
export const PostV1DeletePostRequestInputRef = builder.inputRef<DeletePostRequest>('PostV1DeletePostRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
  }),
});

/**
 * @generated from message post.v1.ListPostsRequest
 */
export const PostV1ListPostsRequestInputRef = builder.inputRef<ListPostsRequest>('PostV1ListPostsRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: int32 page_size = 1;
     */
    pageSize: t.field({
      type: "Int",
      description: "",
    }),
    /**
     * @generated from field: string page_token = 2;
     */
    pageToken: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: post.v1.PostListFilter filter = 3;
     */
    filter: t.field({
      type: "PostV1PostListFilter",
      description: "",
    }),
    /**
     * @generated from field: post.v1.PostCategory category = 4;
     */
    category: t.field({
      type: "PostV1PostCategory",
      description: "",
    }),
  }),
});

/**
 * @generated from message post.v1.GetPostWithAuthorRequest
 */
export const PostV1GetPostWithAuthorRequestInputRef = builder.inputRef<GetPostWithAuthorRequest>('PostV1GetPostWithAuthorRequestInput').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ description: 'Fake field because GraphQL does not support empty input. Do not use, It does nothing.' }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: "String",
      description: "",
    }),
    /**
     * @generated from field: user.v1.User author = 2;
     */
    author: t.field({
      type: "UserV1UserInput",
      description: "",
    }),
  }),
});

/**
 * A function to make a post.v1.CreatePostRequest input
 */
export function makePostV1CreatePostRequestInput(input: any): CreatePostRequest {
  return create(CreatePostRequestSchema, {
    /**
     * @generated from field: string title = 1;
     */
    title: input?.title,
    /**
     * @generated from field: string content = 2;
     */
    content: input?.content,
    /**
     * @generated from field: post.v1.PostStatus status = 3;
     */
    status: input?.status,
    /**
     * @generated from field: post.v1.PostCategory category = 4;
     */
    category: input?.category,
    /**
     * @generated from field: string author_id = 5;
     */
    authorId: input?.authorId,
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: input?.metadata ? Object.fromEntries(input?.metadata?.map(({ key, value }) => [key, value])) : null,
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: input?.tags,
  });
}

/**
 * A function to make a post.v1.GetPostRequest input
 */
export function makePostV1GetPostRequestInput(input: any): GetPostRequest {
  return create(GetPostRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
  });
}

/**
 * A function to make a post.v1.UpdatePostRequest input
 */
export function makePostV1UpdatePostRequestInput(input: any): UpdatePostRequest {
  return create(UpdatePostRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
    /**
     * @generated from field: string title = 2;
     */
    title: input?.title,
    /**
     * @generated from field: string content = 3;
     */
    content: input?.content,
    /**
     * @generated from field: post.v1.PostStatus status = 4;
     */
    status: input?.status,
    /**
     * @generated from field: post.v1.PostCategory category = 5;
     */
    category: input?.category,
    /**
     * @generated from field: map<string, string> metadata = 6;
     */
    metadata: input?.metadata ? Object.fromEntries(input?.metadata?.map(({ key, value }) => [key, value])) : null,
    /**
     * @generated from field: repeated string tags = 7;
     */
    tags: input?.tags,
  });
}

/**
 * A function to make a post.v1.DeletePostRequest input
 */
export function makePostV1DeletePostRequestInput(input: any): DeletePostRequest {
  return create(DeletePostRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
  });
}

/**
 * A function to make a post.v1.ListPostsRequest input
 */
export function makePostV1ListPostsRequestInput(input: any): ListPostsRequest {
  return create(ListPostsRequestSchema, {
    /**
     * @generated from field: int32 page_size = 1;
     */
    pageSize: input?.pageSize,
    /**
     * @generated from field: string page_token = 2;
     */
    pageToken: input?.pageToken,
    /**
     * @generated from field: post.v1.PostListFilter filter = 3;
     */
    filter: input?.filter,
    /**
     * @generated from field: post.v1.PostCategory category = 4;
     */
    category: input?.category,
  });
}

/**
 * A function to make a post.v1.GetPostWithAuthorRequest input
 */
export function makePostV1GetPostWithAuthorRequestInput(input: any): GetPostWithAuthorRequest {
  return create(GetPostWithAuthorRequestSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
    /**
     * @generated from field: user.v1.User author = 2;
     */
    author: input?.author ? makeUserV1UserInput(input.author) : null,
  });
}

/**
 * @generated from rpc post.v1.PostService.CreatePost
 */
builder.mutationField('postV1PostServiceCreatePost', t => t.field({
  /**
   * @generated from message post.v1.Post
   */
  type: "PostV1Post",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message post.v1.CreatePostRequest
     */
    input: t.arg({
      type: "PostV1CreatePostRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.postV1PostService) throw new Error('postV1PostService is not provided.');
    return context.postV1PostService.createPost(
      makePostV1CreatePostRequestInput(input),
      { headers: context.postV1PostServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc post.v1.PostService.GetPost
 */
builder.queryField('postV1PostServiceGetPost', t => t.field({
  /**
   * @generated from message post.v1.Post
   */
  type: "PostV1Post",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message post.v1.GetPostRequest
     */
    input: t.arg({
      type: "PostV1GetPostRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.postV1PostService) throw new Error('postV1PostService is not provided.');
    return context.postV1PostService.getPost(
      makePostV1GetPostRequestInput(input),
      { headers: context.postV1PostServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc post.v1.PostService.UpdatePost
 */
builder.mutationField('postV1PostServiceUpdatePost', t => t.field({
  /**
   * @generated from message post.v1.Post
   */
  type: "PostV1Post",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message post.v1.UpdatePostRequest
     */
    input: t.arg({
      type: "PostV1UpdatePostRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.postV1PostService) throw new Error('postV1PostService is not provided.');
    return context.postV1PostService.updatePost(
      makePostV1UpdatePostRequestInput(input),
      { headers: context.postV1PostServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc post.v1.PostService.DeletePost
 */
builder.mutationField('postV1PostServiceDeletePost', t => t.field({
  /**
   * @generated from message google.protobuf.Empty
   */
  type: "GoogleProtobufEmpty",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message post.v1.DeletePostRequest
     */
    input: t.arg({
      type: "PostV1DeletePostRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.postV1PostService) throw new Error('postV1PostService is not provided.');
    return context.postV1PostService.deletePost(
      makePostV1DeletePostRequestInput(input),
      { headers: context.postV1PostServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc post.v1.PostService.ListPosts
 */
builder.queryField('postV1PostServiceListPosts', t => t.field({
  /**
   * @generated from message post.v1.ListPostsResponse
   */
  type: "PostV1ListPostsResponse",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message post.v1.ListPostsRequest
     */
    input: t.arg({
      type: "PostV1ListPostsRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.postV1PostService) throw new Error('postV1PostService is not provided.');
    return context.postV1PostService.listPosts(
      makePostV1ListPostsRequestInput(input),
      { headers: context.postV1PostServiceRequestHeaders },
    );
  },
}));

/**
 * @generated from rpc post.v1.PostService.GetPostWithAuthor
 */
builder.queryField('postV1PostServiceGetPostWithAuthor', t => t.field({
  /**
   * @generated from message post.v1.PostWithAuthor
   */
  type: "PostV1PostWithAuthor",
  description: "",
  deprecationReason: undefined,
  args: {
    /**
     * @generated from message post.v1.GetPostWithAuthorRequest
     */
    input: t.arg({
      type: "PostV1GetPostWithAuthorRequestInput",
      required: true,
      description: "",
    }),
  },
  resolve: (_root, { input }, context) => {
    if (!context.postV1PostService) throw new Error('postV1PostService is not provided.');
    return context.postV1PostService.getPostWithAuthor(
      makePostV1GetPostWithAuthorRequestInput(input),
      { headers: context.postV1PostServiceRequestHeaders },
    );
  },
}));

",
    "name": "post/post_pothos.ts",
  },
  {
    "content": "// @generated by pothos-protoc-gen v0.0.3 with parameter "builder_path=../builder"
// @generated from file google/protobuf/timestamp.proto (package google.protobuf, syntax proto3)
/* eslint-disable */

import { builder } from "../../../builder";
import type { Timestamp } from "./timestamp_pb";

/**
 * @generated from message google.protobuf.Timestamp
 */
export const GoogleProtobufTimestampRef = builder.objectRef<Timestamp>('GoogleProtobufTimestamp').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
    /**
     * @generated from field: int64 seconds = 1;
     */
    seconds: t.field({
      type: "String",
      description: "",
      deprecationReason: "",
      resolve: (parent) => (parent.seconds)?.toString(),
    }),
    /**
     * @generated from field: int32 nanos = 2;
     */
    nanos: t.field({
      type: "Int",
      description: "",
      deprecationReason: "",
      resolve: (parent) => parent.nanos,
    }),
  }),
});

",
    "name": "google/protobuf/timestamp_pothos.ts",
  },
  {
    "content": "// @generated by pothos-protoc-gen v0.0.3 with parameter "builder_path=../builder"
// @generated from file google/protobuf/empty.proto (package google.protobuf, syntax proto3)
/* eslint-disable */

import { builder } from "../../../builder";
import type { Empty } from "./empty_pb";

/**
 * @generated from message google.protobuf.Empty
 */
export const GoogleProtobufEmptyRef = builder.objectRef<Empty>('GoogleProtobufEmpty').implement({
  description: "",
  fields: t => ({
    _: t.boolean({ resolve: () => false, description: 'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.' }),
  }),
});

",
    "name": "google/protobuf/empty_pothos.ts",
  },
  {
    "content": "import { builder } from "../builder";

/**
 * @generated from field: map<string, string> metadata = 9 [deprecated = true];
 * @deprecated
 */
export const StringMapEntryRef = builder.objectRef<{ key: string, value: string }>('StringMapEntry').implement({
  description: "Key-value pair for the map field metadata of STRING.",
  fields: t => ({
    key: t.string({ required: true }),
    value: t.field({ type: 'String', nullable: false }),
  }),
});

/**
 * @generated from field: map<string, string> metadata = 6;
 */
export const StringMapEntryInputRef = builder.inputRef<{ key: string, value: string }>('StringMapEntryInput').implement({
  description: "Key-value pair for the map field metadata of STRING.",
  fields: t => ({
    key: t.string({ required: true }),
    value: t.field({ type: 'String', required: true }),
  }),
});

",
    "name": "generated-map-entries.ts",
  },
  {
    "content": "import type { Client } from "@connectrpc/connect";
import type { UserService } from "./user_pb";
import type { PostService } from "./post/post_pb";

export * from './user_pothos';
export * from './post/post_pothos';
export * from './google/protobuf/timestamp_pothos';
export * from './google/protobuf/empty_pothos';
export * from './generated-map-entries';
export interface GeneratedPothosContext {
  userV1UserService: Client<typeof UserService>;
  userV1UserServiceRequestHeaders?: HeadersInit;
  postV1PostService: Client<typeof PostService>;
  postV1PostServiceRequestHeaders?: HeadersInit;
}
",
    "name": "generated-pothos.ts",
  },
]