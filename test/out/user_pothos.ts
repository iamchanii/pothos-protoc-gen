// @generated by pothos-protoc-gen v0.1.1 with parameter "import_extension=js,ts_nocheck=true,builder_path=../builder.js"
// @generated from file user.proto (package user.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { create, enumFromJson } from '@bufbuild/protobuf';
import { encodeBase64 } from '@pothos/core';
import { builder } from '../builder.js';
import { makeGoogleProtobufTimestampInput } from './google/protobuf/timestamp_pothos.js';
import type {
  User,
  UserList,
  UserQuery,
  UserStatus,
  User_Address,
} from './user_pb.js';
import {
  UserQuerySchema,
  UserSchema,
  UserStatusSchema,
  User_AddressSchema,
  User_Address_AddressTypeSchema,
} from './user_pb.js';

/**
 * Top-level enum for user status.
 *
 * @generated from enum user.v1.UserStatus
 */
export const UserV1UserStatusRef = builder.enumType('UserV1UserStatus', {
  description: 'Top-level enum for user status.',
  values: {
    /**
     * @generated from enum value: UNKNOWN = 0;
     */
    UNKNOWN: {
      value: enumFromJson(UserStatusSchema, 'UNKNOWN'),
      description: undefined,
      deprecated: false,
    },
    /**
     * @generated from enum value: ACTIVE = 1;
     */
    ACTIVE: {
      value: enumFromJson(UserStatusSchema, 'ACTIVE'),
      description: undefined,
      deprecated: false,
    },
    /**
     * @generated from enum value: INACTIVE = 2;
     */
    INACTIVE: {
      value: enumFromJson(UserStatusSchema, 'INACTIVE'),
      description: undefined,
      deprecated: false,
    },
    /**
     * @generated from enum value: BANNED = 3;
     */
    BANNED: {
      value: enumFromJson(UserStatusSchema, 'BANNED'),
      description: undefined,
      deprecated: false,
    },
  } as const,
});

/**
 * Nested enum within Address for address type.
 *
 * @generated from enum user.v1.User.Address.AddressType
 */
export const UserV1UserAddress_AddressTypeRef = builder.enumType(
  'UserV1UserAddress_AddressType',
  {
    description: 'Nested enum within Address for address type.',
    values: {
      /**
       * @generated from enum value: HOME = 0;
       */
      HOME: {
        value: enumFromJson(User_Address_AddressTypeSchema, 'HOME'),
        description: undefined,
        deprecated: false,
      },
      /**
       * @generated from enum value: WORK = 1;
       */
      WORK: {
        value: enumFromJson(User_Address_AddressTypeSchema, 'WORK'),
        description: undefined,
        deprecated: false,
      },
      /**
       * @generated from enum value: OTHER = 2;
       */
      OTHER: {
        value: enumFromJson(User_Address_AddressTypeSchema, 'OTHER'),
        description: undefined,
        deprecated: false,
      },
    } as const,
  },
);

/**
 * Message representing a user.
 *
 * @generated from message user.v1.User
 */
export const UserV1UserRef = builder.objectRef<User>('UserV1User').implement({
  description: 'Message representing a user.',
  deprecationReason: undefined,
  fields: (t) => ({
    _: t.boolean({
      resolve: () => false,
      description:
        'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.',
    }),
    /**
     * @generated from field: string id = 1;
     */
    id: t.field({
      type: 'ID',
      nullable: false,
      resolve: (parent) => encodeBase64(`UserV1User:${parent.id}`),
      description: undefined,
      deprecationReason: undefined,
    }),
    rawId: t.field({
      type: 'String',
      resolve: (parent) => String(parent.id),
    }),
    /**
     * @generated from field: string name = 2;
     */
    name: t.field({
      type: 'String',
      resolve: (parent) => parent.name,
      description: undefined,
      deprecationReason: undefined,
    }),
    /**
     * @generated from field: user.v1.UserStatus status = 3;
     */
    status: t.field({
      type: 'UserV1UserStatus',
      resolve: (parent) => enumFromJson(UserStatusSchema, parent.status),
      description: undefined,
      deprecationReason: undefined,
    }),
    /**
     * @generated from field: google.protobuf.Timestamp created_at = 4;
     */
    createdAt: t.field({
      type: 'GoogleProtobufTimestamp',
      resolve: (parent) => parent.createdAt,
      description: undefined,
      deprecationReason: undefined,
    }),
    /**
     * Map field with scalar value type.
     *
     * @generated from field: map<string, int32> login_counts = 5;
     */
    loginCounts: t.field({
      type: ['IntMapEntry'],
      resolve: (parent) =>
        Object.entries(parent.loginCounts).map(([key, value]) => ({
          key: String(key),
          value: value,
        })),
      description: 'Map field with scalar value type.',
      deprecationReason: undefined,
    }),
    /**
     * Map field with enum value type.
     *
     * @generated from field: map<string, user.v1.UserStatus> account_settings = 6;
     */
    accountSettings: t.field({
      type: ['String_UserV1UserStatusMapEntry'],
      resolve: (parent) =>
        Object.entries(parent.accountSettings).map(([key, value]) => ({
          key: String(key),
          value: value,
        })),
      description: 'Map field with enum value type.',
      deprecationReason: undefined,
    }),
    /**
     * Address field with message value type.
     * Deprecated field, should not be used in new code.
     *
     * @generated from field: user.v1.User.Address address = 7 [deprecated = true];
     * @deprecated
     */
    address: t.field({
      type: 'UserV1User_Address',
      resolve: (parent) => parent.address,
      description:
        'Address field with message value type.\n Deprecated field, should not be used in new code.',
      deprecationReason: 'Deprecated. See the comments for more details.',
    }),
    /**
     * Map field with message value type.
     *
     * @generated from field: map<string, user.v1.User.Address> addresses = 8;
     */
    addresses: t.field({
      type: ['String_UserV1User_AddressMapEntry'],
      resolve: (parent) =>
        Object.entries(parent.addresses).map(([key, value]) => ({
          key: String(key),
          value: value,
        })),
      description: 'Map field with message value type.',
      deprecationReason: undefined,
    }),
  }),
});

/**
 * Nested message representing an address.
 *
 * @generated from message user.v1.User.Address
 */
export const UserV1User_AddressRef = builder
  .objectRef<User_Address>('UserV1User_Address')
  .implement({
    description: 'Nested message representing an address.',
    deprecationReason: undefined,
    fields: (t) => ({
      _: t.boolean({
        resolve: () => false,
        description:
          'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.',
      }),
      /**
       * @generated from field: string street = 1;
       */
      street: t.field({
        type: 'String',
        resolve: (parent) => parent.street,
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string city = 2;
       */
      city: t.field({
        type: 'String',
        resolve: (parent) => parent.city,
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string state = 3;
       */
      state: t.field({
        type: 'String',
        resolve: (parent) => parent.state,
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string postal_code = 4;
       */
      postalCode: t.field({
        type: 'String',
        resolve: (parent) => parent.postalCode,
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: user.v1.User.Address.AddressType type = 5;
       */
      type: t.field({
        type: 'UserV1UserAddress_AddressType',
        resolve: (parent) =>
          enumFromJson(User_Address_AddressTypeSchema, parent.type),
        description: undefined,
        deprecationReason: undefined,
      }),
    }),
  });

/**
 * Message representing a list of users.
 *
 * @generated from message user.v1.UserList
 */
export const UserV1UserListRef = builder
  .objectRef<UserList>('UserV1UserList')
  .implement({
    description: 'Message representing a list of users.',
    deprecationReason: undefined,
    fields: (t) => ({
      _: t.boolean({
        resolve: () => false,
        description:
          'Fake field because GraphQL does not support empty objects. Do not query, use __typename instead.',
      }),
      /**
       * @generated from field: repeated user.v1.User users = 1;
       */
      users: t.field({
        type: ['UserV1User'],
        resolve: (parent) => parent.users,
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: int32 total_users = 2;
       */
      totalUsers: t.field({
        type: 'Int',
        resolve: (parent) => parent.totalUsers,
        description: undefined,
        deprecationReason: undefined,
      }),
    }),
  });

/**
 * Map field with enum value type.
 *
 * @generated from field: map<string, user.v1.UserStatus> account_settings = 6;
 */
export const String_UserV1UserStatusMapEntryRef = builder
  .objectRef<{ key: string; value: UserStatus }>(
    'String_UserV1UserStatusMapEntry',
  )
  .implement({
    description:
      'Key-value pair for the map field accountSettings of user.v1.UserStatus.',
    fields: (t) => ({
      key: t.exposeString('key', { nullable: false }),
      value: t.expose('value', { type: 'UserV1UserStatus', nullable: false }),
    }),
  });

/**
 * Map field with message value type.
 *
 * @generated from field: map<string, user.v1.User.Address> addresses = 8;
 */
export const String_UserV1User_AddressMapEntryRef = builder
  .objectRef<{ key: string; value: User_Address }>(
    'String_UserV1User_AddressMapEntry',
  )
  .implement({
    description:
      'Key-value pair for the map field addresses of user.v1.User.Address.',
    fields: (t) => ({
      key: t.exposeString('key', { nullable: false }),
      value: t.expose('value', { type: 'UserV1User_Address', nullable: false }),
    }),
  });

/**
 * Message for querying users. References User indirectly.
 *
 * @generated from message user.v1.UserQuery
 */
export const UserV1UserQueryInputRef = builder
  .inputRef<UserQuery>('UserV1UserQueryInput')
  .implement({
    description: 'Message for querying users. References User indirectly.',
    deprecationReason: undefined,
    fields: (t) => ({
      _: t.boolean({
        description:
          'Fake field because GraphQL does not support empty input. Do not use, It does nothing.',
      }),
      /**
       * @generated from field: string search_term = 1;
       */
      searchTerm: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: int32 page_number = 2;
       */
      pageNumber: t.field({
        type: 'Int',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: int32 results_per_page = 3;
       */
      resultsPerPage: t.field({
        type: 'Int',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: google.protobuf.Timestamp start_date = 4;
       */
      startDate: t.field({
        type: 'GoogleProtobufTimestampInput',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: google.protobuf.Timestamp end_date = 5;
       */
      endDate: t.field({
        type: 'GoogleProtobufTimestampInput',
        description: undefined,
        deprecationReason: undefined,
      }),
    }),
  });

/**
 * Message representing a user.
 *
 * @generated from message user.v1.User
 */
export const UserV1UserInputRef = builder
  .inputRef<User>('UserV1UserInput')
  .implement({
    description: 'Message representing a user.',
    deprecationReason: undefined,
    fields: (t) => ({
      _: t.boolean({
        description:
          'Fake field because GraphQL does not support empty input. Do not use, It does nothing.',
      }),
      /**
       * @generated from field: string id = 1;
       */
      id: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string name = 2;
       */
      name: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: user.v1.UserStatus status = 3;
       */
      status: t.field({
        type: 'UserV1UserStatus',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: google.protobuf.Timestamp created_at = 4;
       */
      createdAt: t.field({
        type: 'GoogleProtobufTimestampInput',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * Map field with scalar value type.
       *
       * @generated from field: map<string, int32> login_counts = 5;
       */
      loginCounts: t.field({
        type: ['IntMapEntryInput'],
        description: 'Map field with scalar value type.',
        deprecationReason: undefined,
      }),
      /**
       * Map field with enum value type.
       *
       * @generated from field: map<string, user.v1.UserStatus> account_settings = 6;
       */
      accountSettings: t.field({
        type: ['String_UserV1UserStatusMapEntryInput'],
        description: 'Map field with enum value type.',
        deprecationReason: undefined,
      }),
      /**
       * Address field with message value type.
       * Deprecated field, should not be used in new code.
       *
       * @generated from field: user.v1.User.Address address = 7 [deprecated = true];
       * @deprecated
       */
      address: t.field({
        type: 'UserV1User_AddressInput',
        description:
          'Address field with message value type.\n Deprecated field, should not be used in new code.',
        deprecationReason: 'Deprecated. See the comments for more details.',
      }),
      /**
       * Map field with message value type.
       *
       * @generated from field: map<string, user.v1.User.Address> addresses = 8;
       */
      addresses: t.field({
        type: ['String_UserV1User_AddressMapEntryInput'],
        description: 'Map field with message value type.',
        deprecationReason: undefined,
      }),
    }),
  });

/**
 * Nested message representing an address.
 *
 * @generated from message user.v1.User.Address
 */
export const UserV1User_AddressInputRef = builder
  .inputRef<User_Address>('UserV1User_AddressInput')
  .implement({
    description: 'Nested message representing an address.',
    deprecationReason: undefined,
    fields: (t) => ({
      _: t.boolean({
        description:
          'Fake field because GraphQL does not support empty input. Do not use, It does nothing.',
      }),
      /**
       * @generated from field: string street = 1;
       */
      street: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string city = 2;
       */
      city: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string state = 3;
       */
      state: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: string postal_code = 4;
       */
      postalCode: t.field({
        type: 'String',
        description: undefined,
        deprecationReason: undefined,
      }),
      /**
       * @generated from field: user.v1.User.Address.AddressType type = 5;
       */
      type: t.field({
        type: 'UserV1UserAddress_AddressType',
        description: undefined,
        deprecationReason: undefined,
      }),
    }),
  });

/**
 * Map field with enum value type.
 *
 * @generated from field: map<string, user.v1.UserStatus> account_settings = 6;
 */
export const String_UserV1UserStatusMapEntryInputRef = builder
  .inputRef<{ key: string; value: UserStatus }>(
    'String_UserV1UserStatusMapEntryInput',
  )
  .implement({
    description:
      'Key-value pair for the map field accountSettings of user.v1.UserStatus.',
    fields: (t) => ({
      key: t.string({ required: true }),
      value: t.field({ type: 'UserV1UserStatus', required: true }),
    }),
  });

/**
 * Map field with message value type.
 *
 * @generated from field: map<string, user.v1.User.Address> addresses = 8;
 */
export const String_UserV1User_AddressMapEntryInputRef = builder
  .inputRef<{ key: string; value: User_Address }>(
    'String_UserV1User_AddressMapEntryInput',
  )
  .implement({
    description:
      'Key-value pair for the map field addresses of user.v1.User.Address.',
    fields: (t) => ({
      key: t.string({ required: true }),
      value: t.field({ type: 'UserV1User_AddressInput', required: true }),
    }),
  });

/**
 * A function to make a user.v1.UserQuery input
 */
export function makeUserV1UserQueryInput(input: any): UserQuery {
  return create(UserQuerySchema, {
    /**
     * @generated from field: string search_term = 1;
     */
    searchTerm: input?.searchTerm,
    /**
     * @generated from field: int32 page_number = 2;
     */
    pageNumber: input?.pageNumber,
    /**
     * @generated from field: int32 results_per_page = 3;
     */
    resultsPerPage: input?.resultsPerPage,
    /**
     * @generated from field: google.protobuf.Timestamp start_date = 4;
     */
    startDate: input?.startDate
      ? makeGoogleProtobufTimestampInput(input.startDate)
      : null,
    /**
     * @generated from field: google.protobuf.Timestamp end_date = 5;
     */
    endDate: input?.endDate
      ? makeGoogleProtobufTimestampInput(input.endDate)
      : null,
  });
}

/**
 * A function to make a user.v1.User input
 */
export function makeUserV1UserInput(input: any): User {
  return create(UserSchema, {
    /**
     * @generated from field: string id = 1;
     */
    id: input?.id,
    /**
     * @generated from field: string name = 2;
     */
    name: input?.name,
    /**
     * @generated from field: user.v1.UserStatus status = 3;
     */
    status: input?.status,
    /**
     * @generated from field: google.protobuf.Timestamp created_at = 4;
     */
    createdAt: input?.createdAt
      ? makeGoogleProtobufTimestampInput(input.createdAt)
      : null,
    /**
     * Map field with scalar value type.
     *
     * @generated from field: map<string, int32> login_counts = 5;
     */
    loginCounts: input?.loginCounts
      ? Object.fromEntries(
          input?.loginCounts?.map(({ key, value }) => [key, value]),
        )
      : null,
    /**
     * Map field with enum value type.
     *
     * @generated from field: map<string, user.v1.UserStatus> account_settings = 6;
     */
    accountSettings: input?.accountSettings
      ? Object.fromEntries(
          input?.accountSettings?.map(({ key, value }) => [key, value]),
        )
      : null,
    /**
     * Address field with message value type.
     * Deprecated field, should not be used in new code.
     *
     * @generated from field: user.v1.User.Address address = 7 [deprecated = true];
     * @deprecated
     */
    address: input?.address ? makeUserV1User_AddressInput(input.address) : null,
    /**
     * Map field with message value type.
     *
     * @generated from field: map<string, user.v1.User.Address> addresses = 8;
     */
    addresses: input?.addresses
      ? Object.fromEntries(
          input?.addresses?.map(({ key, value }) => [
            key,
            makeUserV1User_AddressInput(value),
          ]),
        )
      : null,
  });
}

/**
 * A function to make a user.v1.User.Address input
 */
export function makeUserV1User_AddressInput(input: any): User_Address {
  return create(User_AddressSchema, {
    /**
     * @generated from field: string street = 1;
     */
    street: input?.street,
    /**
     * @generated from field: string city = 2;
     */
    city: input?.city,
    /**
     * @generated from field: string state = 3;
     */
    state: input?.state,
    /**
     * @generated from field: string postal_code = 4;
     */
    postalCode: input?.postalCode,
    /**
     * @generated from field: user.v1.User.Address.AddressType type = 5;
     */
    type: input?.type,
  });
}

/**
 * Retrieves a single user.
 *
 * @generated from rpc user.v1.UserService.GetUser
 */
builder.queryField('userV1UserServiceGetUser', (t) =>
  t.field({
    /**
     * Message representing a user.
     *
     * @generated from message user.v1.User
     */
    type: 'UserV1User',
    description: 'Retrieves a single user.',
    deprecationReason: undefined,
    args: {
      /**
       * A generic empty message that you can re-use to avoid defining duplicated
       * empty messages in your APIs. A typical example is to use it as the request
       * or the response type of an API method. For instance:
       *
       *     service Foo {
       *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
       *     }
       *
       *
       * @generated from message google.protobuf.Empty
       */
      input: t.arg({
        type: 'GoogleProtobufEmptyInput',
        required: true,
        description:
          'A generic empty message that you can re-use to avoid defining duplicated\n empty messages in your APIs. A typical example is to use it as the request\n or the response type of an API method. For instance:\n\n     service Foo {\n       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n     }',
      }),
    },
    resolve: (_root, { input }, context) => {
      if (!context.userV1UserService)
        throw new Error('userV1UserService is not provided.');
      return context.userV1UserService.getUser(
        makeGoogleProtobufEmptyInput(input),
        { headers: context.userV1UserServiceRequestHeaders },
      );
    },
  }),
);

/**
 * Retrieves a list of users based on query parameters.
 *
 * @generated from rpc user.v1.UserService.ListUsers
 */
builder.queryField('userV1UserServiceListUsers', (t) =>
  t.field({
    /**
     * Message representing a list of users.
     *
     * @generated from message user.v1.UserList
     */
    type: 'UserV1UserList',
    description: 'Retrieves a list of users based on query parameters.',
    deprecationReason: undefined,
    args: {
      /**
       * Message for querying users. References User indirectly.
       *
       * @generated from message user.v1.UserQuery
       */
      input: t.arg({
        type: 'UserV1UserQueryInput',
        required: true,
        description: 'Message for querying users. References User indirectly.',
      }),
    },
    resolve: (_root, { input }, context) => {
      if (!context.userV1UserService)
        throw new Error('userV1UserService is not provided.');
      return context.userV1UserService.listUsers(
        makeUserV1UserQueryInput(input),
        { headers: context.userV1UserServiceRequestHeaders },
      );
    },
  }),
);

/**
 * Creates a new user.
 *
 * @generated from rpc user.v1.UserService.CreateUser
 */
builder.mutationField('userV1UserServiceCreateUser', (t) =>
  t.field({
    /**
     * Message representing a user.
     *
     * @generated from message user.v1.User
     */
    type: 'UserV1User',
    description: 'Creates a new user.',
    deprecationReason: undefined,
    args: {
      /**
       * Message representing a user.
       *
       * @generated from message user.v1.User
       */
      input: t.arg({
        type: 'UserV1UserInput',
        required: true,
        description: 'Message representing a user.',
      }),
    },
    resolve: (_root, { input }, context) => {
      if (!context.userV1UserService)
        throw new Error('userV1UserService is not provided.');
      return context.userV1UserService.createUser(makeUserV1UserInput(input), {
        headers: context.userV1UserServiceRequestHeaders,
      });
    },
  }),
);

/**
 * Deletes a user.
 *
 * @generated from rpc user.v1.UserService.DeleteUser
 */
builder.mutationField('userV1UserServiceDeleteUser', (t) =>
  t.field({
    /**
     * A generic empty message that you can re-use to avoid defining duplicated
     * empty messages in your APIs. A typical example is to use it as the request
     * or the response type of an API method. For instance:
     *
     *     service Foo {
     *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
     *     }
     *
     *
     * @generated from message google.protobuf.Empty
     */
    type: 'GoogleProtobufEmpty',
    description: 'Deletes a user.',
    deprecationReason: undefined,
    args: {
      /**
       * Message representing a user.
       *
       * @generated from message user.v1.User
       */
      input: t.arg({
        type: 'UserV1UserInput',
        required: true,
        description: 'Message representing a user.',
      }),
    },
    resolve: (_root, { input }, context) => {
      if (!context.userV1UserService)
        throw new Error('userV1UserService is not provided.');
      return context.userV1UserService.deleteUser(makeUserV1UserInput(input), {
        headers: context.userV1UserServiceRequestHeaders,
      });
    },
  }),
);
